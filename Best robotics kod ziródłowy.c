#pragma config(Sensor, in1,    lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, in2,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in3,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, dgtl1,  switchHigh,     sensorTouch)
#pragma config(Sensor, dgtl2,  switchLow,      sensorTouch)
#pragma config(Motor,  port3,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           armServo,      tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           plackServo,    tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           gateServo,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           cameraServo,   tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           armMotor,      tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void servoMoutionHendler(tMotor servoPort, const int openValue, const int closeValue, const int openButton, const int closeButton);
bool getStatusOfButtonsForAUtonomusDriving();
bool getStatusOfButtonsForSlowedDriving();
void autonomus();
void driveTrain();
void armHandler();
void gateHandler();
void plackRemoverHandler();
void cameraRotationHandler();

//Logic for Autonomus Driving only.
bool isButtonsPressedForAutonomusDriving = false;

//Logic for driveTrain only.
bool isDrivingReversed = true;
bool isReversDrivingButtonsPressed = false;
bool isDrivingSlowDown = false;
bool isButtonsPressedForSlowDownDriving = false;

task main()
{
	//Game loop for continously driving robot.
	while (1)
	{
		//Read value for each driving motor
		/*
		* All functions all called here.
		* in this version of code order of how functions are called don't matter.
		* If you change something in this matter also rememebr to update this coment for next genrations of softwear enginiers
		* in Porter High School BEST Robotics.
		*/
		driveTrain();
		armHandler();
		gateHandler();
		plackRemoverHandler();
		cameraRotationHandler();
		autonomus();
	}
}


void autonomus(){
	if(getStatusOfButtonsForAUtonomusDriving() && !isButtonsPressedForAutonomusDriving)
	{
		const int defaultMotorSpeed = 30;
		const int defaultMotorSpeedingSpeed = 127;
		const int defaultTurnSpeed = 40;
		const int defaultTurboTurningSpeed = -35;
		const int threshold = 1750;

		int leftMotorSpeed;
		int rightMotorSpeed;
		int turnSpeed;
		isButtonsPressedForAutonomusDriving = true;
		bool isTimerRestarted = false;

		if(vexRT[Btn5D] && vexRT[Btn6U] && vexRT[Btn5U] && vexRT[Btn6D]){
			leftMotorSpeed = defaultTurnSpeed;
			rightMotorSpeed = defaultTurnSpeed;
			turnSpeed = defaultTurboTurningSpeed;
		}
		else{
			leftMotorSpeed = defaultMotorSpeed;
			rightMotorSpeed = defaultMotorSpeed;
		}

		motor[armMotor] = 0;
		clearTimer(T1);
		while(!getStatusOfButtonsForAUtonomusDriving() || isButtonsPressedForAutonomusDriving)
		{
			if(!getStatusOfButtonsForAUtonomusDriving()) isButtonsPressedForAutonomusDriving = false;

			//Handle if time passed for slowing down.
			if(time100[T1] > 17){
				leftMotorSpeed = defaultMotorSpeed;
				rightMotorSpeed = defaultMotorSpeed;
				turnSpeed = defaultTurnSpeed;
			}

			//Handler for going straight with biger amount of power.
			//This functionality was added becouse sometimes robot was stacking and more power was sollution.
			if((time100[T1] > 300 && !isTimerRestarted) || (time100[T1] > 100 && isTimerRestarted)){
				motor[leftMotor]	= defaultMotorSpeedingSpeed;
				motor[rightMotor] = defaultMotorSpeedingSpeed;
			}

			//This conditions is strt going back robot if stack based on dfineded amount of time.
			if((time100[T1] > 350 && !isTimerRestarted) || (time100[T1] > 150 && isTimerRestarted)){
				clearTimer(T1);
				for(int i = 0; i < 19000; ++i){
					motor[leftMotor] = -40;
					motor[rightMotor] = -40;
				}
			}

			// Left sensor sees dark : Center sensor sees white : Right sensors see, then go straight.
			if(SensorValue(lineFollowerLEFT) > threshold && SensorValue(lineFollowerCENTER) < threshold && SensorValue(lineFollowerRIGHT) > threshold)
			{
				motor[leftMotor]	= leftMotorSpeed;
				motor[rightMotor] = rightMotorSpeed;
			}
			// Left sensor see dark: Center sensor see dark or white : RIGHT sensor sees white, then go left.
			if(SensorValue(lineFollowerLEFT) > threshold && SensorValue(lineFollowerRIGHT) < threshold)
			{
				motor[leftMotor] = leftMotorSpeed;
				motor[rightMotor] = turnSpeed;
			}
			// Left sensor sees white: Center sensor see dark or white: Right Sensor seeing dark, then go right.
			if(SensorValue(lineFollowerLEFT) < threshold && SensorValue(lineFollowerRIGHT) > threshold)
			{
				motor[leftMotor] = turnSpeed;
				motor[rightMotor] = rightMotorSpeed;
			}
		}
		isButtonsPressedForAutonomusDriving = true;
	}
	if(!getStatusOfButtonsForAUtonomusDriving()) isButtonsPressedForAutonomusDriving = false;
}


void driveTrain(){

	/*
	* Purpos of this function is to handle driving of robot.
	*/

	static const float defaultDrivingSpeedModifier = 1;
	static const float defaultDrivingSlowDownSpeedModifier = 0.28;
	const float drivingSpeedModifier = isDrivingSlowDown ? defaultDrivingSlowDownSpeedModifier : defaultDrivingSpeedModifier;


	//reverse driving direction
	//This pice of code is just handling if driving sholude be tougled.
	if(vexRT[Btn8L] && vexRT[Btn8R])
	{
		if(!isReversDrivingButtonsPressed){
			isDrivingReversed = !isDrivingReversed;
			isReversDrivingButtonsPressed = true;
		}
	}
	else
	{
		isReversDrivingButtonsPressed = false;
	}

	//slowdown driving
	//This pice of code is just handling change of modifier of driving speed when correct buttons are pressed.
	if(getStatusOfButtonsForSlowedDriving() && !isButtonsPressedForSlowDownDriving){
		isDrivingSlowDown = !isDrivingSlowDown;
		isButtonsPressedForSlowDownDriving = true;
	}

	if(isButtonsPressedForSlowDownDriving && !getStatusOfButtonsForSlowedDriving()){
		isButtonsPressedForSlowDownDriving = false;
	}


	//Drive controler.
	//This pice of code is just hndling input from controle to motors and modidy this depends on slowmode and reversmode.
	if(isDrivingReversed)
	{
		motor(rightMotor)= -vexRT(Ch3) * drivingSpeedModifier;
		motor(leftMotor) = -vexRT(Ch2) * drivingSpeedModifier;
	}
	else
	{
		motor(leftMotor)= vexRT(Ch3) * drivingSpeedModifier;
		motor(rightMotor) = vexRT(Ch2) * drivingSpeedModifier;
	}
}

void armHandler(){
	/*
	* This function is handler for arm.
	* If button Btn5U is pressed go up with default power.
	* If button Btn5D is pressed go down with default power.
	* If button Btn8L is pressed go up with full power.
	* If button Btn8R is pressed go down with full power.
	* If nothing press just idle arm, we using a little bit power
	*/

	const int defaulArmUpValue = -70;
	const int defaulArmDownValue = 50;
	const int defaultArmIdleValue = -15;
	const int defaulArmOpenValue = -127;
	const int defaulArmCloseValue = 127;

	if(SensorValue(switchLow) || SensorValue(switchHigh)) motor[armMotor] = 0;
	else if(vexRT(Btn5U)) motor[armMotor] = defaulArmUpValue;
	else if(vexRT(Btn8L)) motor[armMotor] = -127;
	else if(vexRT(Btn5D)) motor[armMotor] = defaulArmDownValue;
	else if(vexRT(Btn8R)) motor[armMotor] = 127;
	else motor[armMotor] = defaultArmIdleValue;
	servoMoutionHendler(armServo, defaulArmOpenValue, defaulArmCloseValue,Btn6U, Btn6D);
}

void gateHandler(){
	/*
	* Resposibilitty of this functions is to handle gate movment.
	* If Btn8U is pressed gate will be moved to Up position.
	* If Btn8D is pressed gate will be moved to Down position.
	* if Btn7D is pressed gate also should go Up.
	* When driver press button to lower plack remover I assume that he what to collect plack and gate shoulde be Up.
	* This feature I've add after my round where I didn't noticed that my gate was down. That's why I've add this feature.
	*/

	const int defaultGateUpValue = -127;
	const int defaultGateDownValue = 50;
	servoMoutionHendler(gateServo,defaultGateUpValue, defaultGateDownValue, Btn8U, Btn8D);
	if(vexRT[Btn7D]) motor[gateServo] = defaultGateUpValue;
}

void plackRemoverHandler(){
	/*
	* Responsibility of this funnction is to hanndle plack remover movment.
	* If Btn7U is pressed plack remover will be moved to high position.
	* If Btn7D is pressed plack remover will be moved to low position.
	* If Btn7U and Btn7D are pressed plack remover will be move to mid position.
	* If Btn8D is pressed plack remover also should go up, to not block plack when we want to unload.
	* In this funtion I'm using timer T1 becouse if you put plack remover to middle position
	* you proably want to stay in that posittion.
	* When you press two buttons which are alos used to put plack remover hihg or low position.
	* I needed some how to give a little time for diver. This was my ideia how to solve this.
	* If you have better fill free to change.
	* Now you are softwear enginger and you know the best what you need.
	*/

	static const int defaultPlackUpValue = 95;
	static const int defaultPlackDownValue = 40;

	if(time100(T1) > 5) servoMoutionHendler(plackServo,defaultPlackUpValue, defaultPlackDownValue, Btn7U, Btn7D);

	if(vexRT[Btn7D] && vexRT[Btn7U]){
		motor[plackServo] = 80;
		clearTimer(T1);
	}

	if(vexRT[Btn8D]) motor[plackServo] = defaultPlackUpValue;
}

void cameraRotationHandler(){
	/*
	* This function resposibility is to move camera to the left and right.
	* If pressed btn7L camera scholud be moved to the left of course if we don't go to limit for servo.
	* If pressed btn7R camera scholud be moved to the right of course if we don't go to limit for servo.
	* If pressed both btn7L and btn7R camera will be move to chentre position.
	*/

	static const int speedOfTurningCameraInDegrees = 1;
	static const int howLongWaitBetweenNextMoveOfCamera = 5;
	static const int centrePositionOfcamera = 0;

	if(vexRT[Btn7R] && motor[cameraServo] > -127 + speedOfTurningCameraInDegrees ){
		motor[cameraServo] -= speedOfTurningCameraInDegrees;
		wait1Msec(howLongWaitBetweenNextMoveOfCamera);
	}
	if(vexRT[Btn7L] && motor[cameraServo] < 127 - speedOfTurningCameraInDegrees){
		motor[cameraServo] += speedOfTurningCameraInDegrees;
		wait1Msec(howLongWaitBetweenNextMoveOfCamera);
	}
	if(vexRT[Btn7L] && vexRT[Btn7R]){
		motor[cameraServo] = centrePositionOfcamera;
		wait1Msec(howLongWaitBetweenNextMoveOfCamera);
	}
}

void servoMoutionHendler(tMotor servoPort,const int openValue, const int closeValue, const int openButton, const int closeButton){
	/*
	* @param tMotor servoPort; Is saying to function on which motor port we want to operate.
	* @param const int openValue; This param is saing to what value you wont to set your servo as open or high position for exampel.
	* @param const int closeValue; This param is saiong to what value you want to set your servo as close or low position for exampel.
	* @param const int openButton; This param is saing to for which button fuction should liste to change to high position.
	* @param const int closeButton; This param is saing to for which button fuction should liste to change to low position.
	*
	* This handler whose written to handle simple envents for most of servos where you seting something for high or low position.
	*/

	if(vexRT[openButton]) motor[servoPort] = openValue;
	if(vexRT[closeButton]) motor[servoPort] = closeValue;
}

bool getStatusOfButtonsForAUtonomusDriving(){
	return (vexRT[Btn5U] && vexRT[Btn6U]) || (vexRT[Btn5D] && vexRT[Btn6U] && vexRT[Btn5U] && vexRT[Btn6D]);
}

bool getStatusOfButtonsForSlowedDriving(){
	return vexRT[Btn5D] && vexRT[Btn6D];
}
